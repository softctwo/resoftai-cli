# ResoftAI 系统架构文档

## 系统概述

ResoftAI 是一个基于多智能体协作的软件开发自动化平台，通过AI智能体模拟真实软件开发团队，自动化完成从需求到交付的全流程。

## 核心架构

### 1. 分层架构

```
┌─────────────────────────────────────────┐
│         用户界面层 (Interface Layer)        │
│   ┌──────────┐         ┌──────────┐    │
│   │   CLI    │         │  Web API │    │
│   └──────────┘         └──────────┘    │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│        业务逻辑层 (Business Layer)         │
│   ┌──────────────┐  ┌──────────────┐   │
│   │ 工作流引擎    │  │  智能体管理   │   │
│   └──────────────┘  └──────────────┘   │
│   ┌──────────────┐  ┌──────────────┐   │
│   │ 文档生成器    │  │  任务调度     │   │
│   └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│         核心层 (Core Layer)               │
│   ┌──────────────────────────────────┐  │
│   │        智能体基础框架              │  │
│   │  (Agent Base, Message Bus, State) │  │
│   └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│         基础设施层 (Infrastructure)       │
│   ┌──────────┐  ┌──────────┐           │
│   │ Claude AI│  │ 配置管理  │           │
│   └──────────┘  └──────────┘           │
└─────────────────────────────────────────┘
```

### 2. 组件架构

#### 2.1 核心组件

**Agent (智能体基类)**
- 定义所有智能体的共同行为
- 提供与Claude AI的交互接口
- 实现消息处理和状态管理
- 支持能力注册和工作流集成

**MessageBus (消息总线)**
- 实现发布-订阅模式
- 支持异步消息传递
- 消息历史记录和追踪
- 主题路由和过滤

**ProjectState (项目状态)**
- 集中式状态管理
- 支持任务追踪
- 决策记录
- 文档关联
- 持久化支持

**ProjectWorkflow (工作流引擎)**
- 定义标准开发流程
- 阶段转换管理
- 任务分配和追踪
- 智能体协调

#### 2.2 智能体架构

每个智能体都是独立的、专业化的AI实体：

```
Agent Base Class
       │
       ├── ProjectManagerAgent
       ├── RequirementsAnalystAgent
       ├── ArchitectAgent
       ├── UXUIDesignerAgent
       ├── DeveloperAgent
       ├── TestEngineerAgent
       └── QualityExpertAgent
```

每个智能体包含：
- **专业系统提示词**: 定义角色和专业知识
- **能力列表**: 声明可执行的操作
- **责任阶段**: 在工作流中的主要职责
- **消息处理**: 处理请求和任务
- **状态访问**: 读写项目状态

## 数据流

### 1. 项目创建流程

```
用户输入需求
    │
    ▼
初始化组件 (MessageBus, ProjectState, Workflow)
    │
    ▼
创建智能体实例 (7个专业智能体)
    │
    ▼
启动工作流 (Workflow.start)
    │
    ▼
按阶段执行
    │
    ├─► 需求收集 → 项目经理 + 需求分析师
    ├─► 需求分析 → 需求分析师
    ├─► 架构设计 → 架构师
    ├─► UI/UX设计 → UX/UI设计师
    ├─► 原型开发 → 开发工程师
    ├─► 客户评审 → 项目经理
    ├─► 需求优化 → 需求分析师
    ├─► 开发计划 → 项目经理
    ├─► 实施开发 → 开发工程师
    ├─► 测试执行 → 测试工程师
    ├─► 质量保证 → 质量专家
    ├─► 文档生成 → 文档生成器
    └─► 部署交付 → 项目经理
    │
    ▼
生成交付物 (文档 + 状态文件)
```

### 2. 消息传递流程

```
智能体A发送消息
    │
    ▼
MessageBus.publish()
    │
    ├─► 记录到消息历史
    ├─► 匹配订阅主题
    └─► 调用订阅者回调
        │
        ▼
    智能体B接收消息
        │
        ▼
    处理并可能发送响应
```

## 技术栈

### 后端
- **语言**: Python 3.9+
- **AI模型**: Anthropic Claude (Claude 3.5 Sonnet)
- **Web框架**: FastAPI
- **CLI框架**: Click
- **异步**: asyncio
- **数据验证**: Pydantic

### 依赖库
- anthropic: Claude API客户端
- click: CLI构建
- rich: 终端美化
- fastapi: Web API
- uvicorn: ASGI服务器
- pydantic: 数据验证
- jinja2: 模板引擎
- pyyaml: 配置管理

## 设计模式

### 1. 观察者模式 (Observer Pattern)
消息总线实现了观察者模式，智能体可以订阅感兴趣的消息类型。

### 2. 策略模式 (Strategy Pattern)
每个智能体实现不同的处理策略，但共享相同的接口。

### 3. 工厂模式 (Factory Pattern)
文档生成器使用工厂模式创建不同类型的文档。

### 4. 状态模式 (State Pattern)
工作流通过状态转换管理项目进度。

## 扩展性

### 添加新智能体

1. 继承 `Agent` 基类
2. 实现必需的属性和方法
3. 定义专业系统提示词
4. 声明能力和责任阶段
5. 在工作流中注册

```python
class NewAgent(Agent):
    @property
    def name(self) -> str:
        return "New Agent"

    @property
    def system_prompt(self) -> str:
        return "You are a..."

    # ... 其他实现
```

### 添加新工作流阶段

1. 在 `WorkflowStage` 枚举中添加新阶段
2. 在 `ProjectWorkflow.WORKFLOW_SEQUENCE` 中插入
3. 在 `ProjectWorkflow.STAGE_AGENTS` 中映射智能体
4. 在 `_get_default_tasks_for_stage` 中定义任务

### 添加新文档类型

1. 继承 `DocumentGenerator` 基类
2. 实现 `generate_content` 方法
3. 定义文档名称和文件名
4. 在 CLI 或 API 中注册

## 安全考虑

1. **API密钥管理**: 使用环境变量，不提交到版本控制
2. **输入验证**: 使用Pydantic验证所有输入
3. **错误处理**: 完善的异常处理和日志记录
4. **访问控制**: API可扩展为支持认证授权

## 性能优化

1. **异步处理**: 使用asyncio提高并发性能
2. **消息批处理**: 减少API调用次数
3. **缓存机制**: 缓存常用的AI响应
4. **资源池**: 复用智能体实例

## 监控和日志

- 使用Python标准logging库
- 记录所有智能体操作
- 追踪消息流
- 性能指标收集

## 未来架构演进

1. **分布式部署**: 支持多节点部署
2. **数据持久化**: 使用数据库替代文件存储
3. **任务队列**: 使用Celery等任务队列
4. **微服务化**: 拆分为独立的微服务
5. **容器化**: Docker支持
6. **云原生**: Kubernetes部署支持
